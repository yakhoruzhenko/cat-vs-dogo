# -*- coding: utf-8 -*-
"""cat_vs_dog_0.1

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IP1QAhejIKMsduCF0AQQuB43mzqi9oFK
"""

#Imports
import os
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
keras = tf.keras
!pip install pyyaml h5py

import tensorflow_datasets as tfds
tfds.disable_progress_bar()

# split the data manually into 90% training, 10% validation
(raw_train, raw_validation), metadata = tfds.load(
    'cats_vs_dogs',
    split=['train[:90%]', 'train[90%:]'],
    with_info=True,
    as_supervised=True,
)

IMG_SIZE = 160 # All images will be resized to 160x160

def format_example(image, label):
  """
  returns an image that is reshaped to IMG_SIZE
  """
  image = tf.cast(image, tf.float32)
  image = image/255.0
  image = tf.image.resize(image, [IMG_SIZE, IMG_SIZE])
  
  return image, label

train = raw_train.map(format_example)
validation = raw_validation.map(format_example)

BATCH_SIZE = 32
SHUFFLE_BUFFER_SIZE = 1000

train_batches = train.shuffle(SHUFFLE_BUFFER_SIZE).batch(BATCH_SIZE)
validation_batches = validation.batch(BATCH_SIZE)

IMG_SHAPE = (IMG_SIZE, IMG_SIZE, 3)

# Create the base model from the pre-trained model MobileNet V2
base_model = tf.keras.applications.MobileNetV2(input_shape=IMG_SHAPE,
                                               include_top=False,
                                               weights='imagenet')

base_model.trainable = False

global_average_layer = tf.keras.layers.GlobalAveragePooling2D()

prediction_layer = keras.layers.Dense(1, activation='sigmoid')

model = tf.keras.Sequential([
  base_model,
  global_average_layer,
  prediction_layer
])

##If I need to download h5
#from google.colab import files
#files.download("dogs_vs_cats.h5")

model = tf.keras.models.load_model('/content/drive/MyDrive/dogs_vs_cats.h5')
#model = tf.keras.models.load_model("dogs_vs_cats.h5")

base_learning_rate = 0.001
model.compile(optimizer=tf.keras.optimizers.SGD(learning_rate=base_learning_rate, momentum=0.9, nesterov=True),
              loss=tf.keras.losses.BinaryCrossentropy(from_logits=False),
              metrics=['accuracy'])

initial_epochs = 5

# Now we can train it on our images
history = model.fit(train_batches,
                    epochs=initial_epochs,
                    validation_data=validation_batches)

acc = history.history['accuracy']
print(acc)
model.save("dogs_vs_cats.h5")

from google.colab import files
files.download("dogs_vs_cats.h5")

#Imports
import os
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
keras = tf.keras
#!pip install pyyaml h5py

from google.colab import drive
drive.mount('/content/drive')

model = tf.keras.models.load_model('/content/drive/MyDrive/dogs_vs_cats.h5')

def TFconverter(self, feature_model):
  converter = tf.lite.TFLiteConverter.from_keras_model(feature_model)
  converter.allow_custom_ops = True
  converter.experimental_new_converter = True
  converter.target_spec.supported_ops = [
                                        tf.lite.OpsSet.TFLITE_BUILTINS,
                                        tf.lite.OpsSet.SELECT_TF_OPS
                                        ]
  converter.optimizations = [tf.lite.Optimize.DEFAULT]
  tflite_model = converter.convert()

  model_converter_file = pathlib.Path(self.model_converter)
  model_converter_file.write_bytes(tflite_model)

converter = tf.lite.TFLiteConverter.from_keras_model(model)
converter.allow_custom_ops = True
converter.experimental_new_converter = True
converter.target_spec.supported_ops = [
                                        tf.lite.OpsSet.TFLITE_BUILTINS,
                                        tf.lite.OpsSet.SELECT_TF_OPS
                                        ]
converter.optimizations = [tf.lite.Optimize.DEFAULT]
tflite_model = converter.convert()

open("cats_dogs.tflite", "wb").write(tflite_model)

from google.colab import files
files.download("cats_dogs.tflite")

converter = tf.compat.v1.lite.TFLiteConverter.from_keras_model_file('/content/drive/MyDrive/dogs_vs_cats.h5')
converter.experimental_new_converter = True
tflite_model = converter.convert()
open("linear.tflite", "wb").write(tflite_model)

from keras.preprocessing.image import load_img, img_to_array

# load and prepare the image
def load_image(filename):
	# load the image
	img = load_img(filename, target_size=(160, 160))
	# convert to array
	img = img_to_array(img)
	# reshape into a single sample with 3 channels
	img = img.reshape(1, 160, 160, 3)
	# center pixel data
	img = img.astype('float32')
	img = img/255.0
	return img

img = load_image('/content/drive/MyDrive/dog6.png')

def predict(img):
  predictions = model.predict(img)

  if np.round_(predictions) == 0:
    return "Кіт"
  else:
    return "Пес"

prediction = predict(img)
plt.figure()
plt.imshow(img[0])
plt.title(prediction)

#Retrieve a batch of images from the test set
image_batch, label_batch = test_dataset.as_numpy_iterator().next()
predictions = model.predict_on_batch(image_batch).flatten()

# Apply a sigmoid since our model returns logits
predictions = tf.nn.sigmoid(predictions)
predictions = tf.where(predictions < 0.5, 0, 1)

print('Predictions:\n', predictions.numpy())
print('Labels:\n', label_batch)

plt.figure(figsize=(10, 10))
for i in range(9):
  ax = plt.subplot(3, 3, i + 1)
  plt.imshow(image_batch[i].astype("uint8"))
  plt.title(class_names[predictions[i]])
  plt.axis("off")